{#    Modification of filters/drillable_async.html  #}
{#        Displays all fields simoltaneously, without needing to drilling-down, #}
{#        where parent nodes are unknown.  #}
{# todo: clean this up to properly inherit from filters/base.html #}
{% load hq_shared_tags %}

<label class="control-label">{{ control_name }}</label> {# this is wrong, this should be inheriting the structure from filters/base.html, see base/drilldown_options #}
<div class="controls">
    <div data-bind="foreach: selected_path" style="display: inline-block;">
        <select multiple=false data-bind="options: children, optionsText: 'display_name', selectedOptions: selected_child"></select>
    </div>
    <img id="fdi_ajax" src="/static/formplayer/img/loading_small.gif" style="display: none;">
</div>
<input name="fixture_id" type="hidden" data-ajax-select2="true"/>

<script type="text/javascript">

    var LOAD_FDIS_URL = '{{ api_root }}';
    var hierarchy = {{ hierarchy|JSON }};
    var selected = {{ selected|safe}};


    function api_get_children(fdi_uuid, depth, callback) {
        var params = (fdi_uuid ? {parent_id: fdi_uuid} : {});
        if(hierarchy[depth] !== undefined) {
            params["parent_ref_name"] = hierarchy[depth]["parent_ref"];
            if (fdi_uuid != "_all") {
                params["child_type"] = hierarchy[depth]["id"];
            }
            else {
                params["fixture_type"] = hierarchy[depth]["type"];
            }
            params["references"] = hierarchy[depth]["references"];
            $('#fdi_ajax').show();
            $.getJSON(LOAD_FDIS_URL, params, function (allData) {
                $('#fdi_ajax').hide();
                callback(allData.objects);
            });
        }
    }

    $(function() {
        var fdis = {{ fdis|safe }};
        $.each(fdis, function(i, fdi){
            //initial list of fdis doesn't contain fixture_type properties
            fdi.fixture_type = hierarchy[0].type;
        });

        var model = new FixtureSelectViewModel();
        ko.applyBindings(model, $('#group_{{ control_slug }}')[0]);
        model.load(fdis, null);
    });

    function FixtureSelectViewModel() {
        var model = this;

        this.root = ko.observable();
        this.selected_path = ko.observableArray();

        // add a new level of drill-down to the tree
        this.path_push = function(fixt) {
            var last = this.selected_path.pop();

            function sort_and_remove_duplicates(array) {
                var filteredArray = [];
                var i;
                $.each(array, function (index, item) {
                    var alreadyAdded = false;
                    for (i in filteredArray) {
                        if (filteredArray[i].uuid() === item.uuid()) {
                            alreadyAdded = true;
                        }
                    }
                    if (!alreadyAdded) {
                        filteredArray.push(item);
                    }
                });

                return filteredArray.sort(function(a, b){
                    a_id = a.uuid();
                    b_id = b.uuid();
                    return a_id > b_id ? 1 : -1;
                });
            }

            if (last !== undefined && last.depth === fixt.depth) {
                last.children(sort_and_remove_duplicates(last.children().concat(fixt.children())));

                this.selected_path.push(last);
            } else {
                if (last !== undefined) this.selected_path.push(last);
                this.selected_path.push(fixt);
            }
            if (fixt.num_children() == 1) {
                fixt.selected_child(fixt.get_child(0));
            }
        };

        // load fixture hierarchy and set initial path
        this.load = function(fdis) {
            this.root(new FixtureModel({name: '_root', fields: {}, children: fdis}, this));
            this.path_push(this.root());

        };
    }

    function FixtureModel(data, root, depth) {
        var fixt = this;
        this.name = ko.observable();
        this.type = ko.observable();
        this.uuid = ko.observable();
        this.children = ko.observableArray();
        this.depth = depth || 0;
        this.children_loaded = false;
        var prev_selected_fixt ;
        var prev_selected_child;
        // helper in loading fixtures fields one by one


        this.display_name = ko.computed(function() {
            if (depth>0 && this.name() == '_all') {

                return "All ("+hierarchy[depth-1]["type"]+")";
            }

            return this.name() == '_all' ? 'All '+data.fixture_type : data.name;
        }, this);

        this.selected_child = ko.observable();
        // when a fixture is selected, update the drill-down tree
        // only if all fixtures are not loaded already at the start
        this.selected_child.subscribe(function() {
            if (this.selected_child().length === 0 && prev_selected_child && prev_selected_fixt.selected_child()) {
{#                Możliwe że chodzi o root -> selected_path ale źle kombinowałem ,tak  to w miare działa trzeba#}
{#                jeszcze ogarnąć po stronie sql_data żeby lepiej wspierało listy bo teraz jest tymczasowo #}
{#                ten plik trzeba skopiować w dobre miejsce i na tym zrobić reverta żeby nie było żadnych zmian w nim#}
                prev_selected_fixt.selected_child( prev_selected_fixt.selected_child().concat([prev_selected_child]));
                return;
            }
            $.each(this.selected_child(), function(id, val) {
                var input_value = [];
                if (val != "_all" && val != null && val.uuid() != "_all") {
                    input_value.push(val.uuid());
                }

                if (id === 0) {
                    var removed = root.selected_path.splice(val.depth, 99);
                }
                var post_children_loaded = function(parent) {
                    if (parent.num_children()) {
                        root.path_push(parent);
                    }
                };
                if (val.uuid() != null) {
                    val.load_children_async(post_children_loaded);
                } else {
                    post_children_loaded(val);
                }
                $("input[name = 'fixture_id']").val(input_value);
            });
        }, this);
        this.selected_is_valid = ko.computed(function() {
            return this.selected_child() && this.selected_child() !="_all" && this.selected_child().name != '_all';
        }, this);

        // helpers to account for the 'all' meta-entry
        this.num_children = ko.computed(function() {
            return (this.children().length == 0 ? 0 : this.children().length - 1);
        }, this);
        this.get_child = function(i) {
            return this.children()[i + 1];
        };

        this.load = function(data) {
            if (data.fields !== undefined && data.fields.name == '_all'){
                this.name('_all');
            } else if (this.depth > 0) {
                this.name(data.name);
            }

            this.type(data.fixture_type);
            this.uuid(data.id || "_all");
            if (data.children !== null && data.children !== undefined) {
                this.set_children(data.children);
            }
        };

        this.set_children = function(data) {
            var children = [];
            if (data) {
                children = _.sortBy(data, function(e) { return e.uuid; });

                //'all choices' meta-entry; annoying that we have to stuff this in
                //the children list, but all my attempts to make computed observables
                //based of children() caused infinite loops.
                children.splice(0, 0, {fields: {name: '_all'}});
            }
            this.children($.map(children, function(e) {
                if ($.inArray(e.uuid, selected) > -1){
                    var to_ret = new FixtureModel(e, root, fixt.depth + 1);
                    prev_selected_fixt = fixt;
                    prev_selected_child = to_ret;
                    return to_ret;
                }
                else
                    return new FixtureModel(e, root, fixt.depth + 1);
            }));
            this.children_loaded = true;
        };

        this.load_children_async = function(callback) {
            var uuid = "_all";
            if (this.uuid()){
                uuid = this.uuid();
            } 
            api_get_children(uuid, this.depth, function(resp) {;
                fixt.set_children(resp);
                callback(fixt);
            });
        };

        this.load(data);
        this.selected_child([])
    }

</script>
